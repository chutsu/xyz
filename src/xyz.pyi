import cProfile
import unittest
from pathlib import Path
from enum import Enum

from typing import TypeVar
from typing import Annotated
from typing import Literal

import cv2
import numpy as np
from numpy.typing import NDArray

DType = TypeVar("DType", bound=np.generic)
Vec2 = Annotated[NDArray[DType], Literal[2]]
Vec3 = Annotated[NDArray[DType], Literal[3]]
Vec4 = Annotated[NDArray[DType], Literal[4]]
Vec5 = Annotated[NDArray[DType], Literal[5]]
Vec6 = Annotated[NDArray[DType], Literal[6]]
Vec7 = Annotated[NDArray[DType], Literal[7]]
VecN = Annotated[NDArray[DType], Literal["N"]]
Mat2 = Annotated[NDArray[DType], Literal[2, 2]]
Mat3 = Annotated[NDArray[DType], Literal[3, 3]]
Mat34 = Annotated[NDArray[DType], Literal[3, 4]]
Mat4 = Annotated[NDArray[DType], Literal[4, 4]]
MatN = Annotated[NDArray[DType], Literal["N", "N"]]
MatNx2 = Annotated[NDArray[DType], Literal["N", "2"]]
MatNx3 = Annotated[NDArray[DType], Literal["N", "3"]]
MatNx4 = Annotated[NDArray[DType], Literal["N", "4"]]
Mat2xN = Annotated[NDArray[DType], Literal["2", "N"]]
Mat2x3 = Annotated[NDArray[DType], Literal["2", "3"]]
Mat3x4 = Annotated[NDArray[DType], Literal["3", "4"]]
Mat3xN = Annotated[NDArray[DType], Literal["3", "N"]]
Mat4xN = Annotated[NDArray[DType], Literal["4", "N"]]
Image = Annotated[NDArray[DType], Literal["N", "N"]]

###############################################################################
# I/O
###############################################################################

def extract_tar_gz(file_path: Path, extract_path: Path) -> bool: ...

###############################################################################
# YAML
###############################################################################

def load_yaml(yaml_path: str): ...

###############################################################################
# TIME
###############################################################################

def sec2ts(time_s: float) -> np.int64: ...
def ts2sec(ts: np.int64) -> np.float64: ...

###############################################################################
# PROFILING
###############################################################################

def profile_start() -> cProfile.Profile: ...
def profile_stop(prof: cProfile.Profile, **kwargs): ...

###############################################################################
# NETWORK
###############################################################################

def download_file(url: str, dst: Path) -> bool: ...
def http_status_code_string(code: int) -> str: ...
def http_parse_request(msg_str: str) -> tuple[str, str, str, dict]: ...
def http_form_request(
  method: str,
  path: str,
  headers: dict,
  protocol: str = "HTTP/1.1",
) -> str: ...
def http_form_response(
  status_code: int,
  headers: dict,
  protocol: str = "HTTP/1.1",
) -> str: ...
def websocket_hash(ws_key: str) -> str: ...
def websocket_handshake_response(ws_key: str) -> str: ...
def websocket_frame_fin_bit(data_frame): ...
def websocket_frame_rsv_bit(data_frame): ...
def websocket_frame_op_code(data_frame): ...
def websocket_frame_mask_enabled(data_frame): ...
def websocket_apply_mask(data: bytes, mask: bytes) -> bytes: ...
def websocket_encode_frame(payload, **kwargs): ...
def websocket_decode_frame(reader, mask): ...

class DebugServer: ...

def test_websocket_callback(): ...

class TestNetwork(unittest.TestCase): ...

###############################################################################
# MATHS
###############################################################################

def rmse(errors: VecN) -> float: ...
def clip_value(x: float, vmin: float, vmax: float) -> float: ...
def wrap_180(d: float) -> float: ...
def wrap_360(d: float) -> float: ...
def wrap_pi(r: float) -> float: ...

###############################################################################
# LINEAR ALGEBRA
###############################################################################

def pprint_matrix(mat: MatN, fmt: str = "g") -> None: ...
def normalize(v: VecN) -> VecN: ...
def full_rank(A: MatN) -> float: ...
def hat(vec: Vec3) -> Mat3: ...
def vee(A: Mat3) -> Vec3: ...
def fwdsubs(L: MatN, b: VecN): ...
def bwdsubs(U: MatN, b: VecN): ...
def solve_svd(A: MatN, b: VecN) -> VecN: ...
def schurs_complement(
  H: MatN,
  g: VecN,
  m: float,
  r: float,
  precond: bool = False,
) -> tuple[MatN, VecN]: ...
def is_pd(B: MatN) -> bool: ...
def nearest_pd(A: MatN) -> MatN: ...
def matrix_equal(
  A: MatN,
  B: MatN,
  tol: float = 1e-8,
  verbose: bool = False,
) -> bool: ...
def plot_compare_matrices(title_A: str, A: MatN, title_B: str, B: MatN): ...
def check_jacobian(
  jac_name: str,
  fdiff: MatN,
  jac: MatN,
  threshold: float,
  verbose: bool = False,
) -> bool: ...

class TestLinearAlgebra(unittest.TestCase): ...

###############################################################################
# GEOMETRY
###############################################################################

def lerp(x0: float | VecN, x1: float | VecN, t: float) -> float | VecN: ...
def lerp2d(p0: Vec2, p1: Vec2, t: float) -> Vec2: ...
def lerp3d(p0: Vec3, p1: Vec3, t: float) -> Vec3: ...
def circle(r: float, theta: float) -> Vec2: ...
def sphere(rho: float, theta: float, phi: float) -> Vec3: ...
def circle_loss(c: Vec2, x: float, y: float) -> float: ...
def find_circle(x: float, y: float) -> tuple[Vec2, float, float]: ...
def bresenham(p0: Vec2, p1: Vec2) -> list[Vec2]: ...
def find_intersection(
  p1: Vec2,
  p2: Vec2,
  q1: Vec2,
  q2: Vec2,
) -> tuple[bool, Vec2, VecN, np.int32]: ...
def fix_rotation_matrix(R): ...

###############################################################################
# LIE
###############################################################################

def Exp(phi: Vec3) -> Mat3: ...
def Log(C: Mat3) -> Vec3: ...
def Jr(theta: Vec3) -> Mat3: ...
def Jr_inv(theta: Vec3) -> Mat3: ...
def SO3_boxplus(C: Mat3, alpha: Vec3) -> Mat3: ...
def SO3_boxminus(C_a: Mat3, C_b: Mat3) -> Vec3: ...
def twistSE3(twist: Vec6) -> Mat4: ...
def so3_exp(so3mat: Mat3, tol=1e-6) -> Mat3: ...
def so3_Exp(w: Vec3) -> Mat3: ...
def poe(screw_axis: Vec6, theta: Vec3, tol: float = 1e-6) -> Mat4: ...

class TestLie(unittest.TestCase): ...

###############################################################################
# TRANSFORM
###############################################################################

def homogeneous(p: Vec3) -> Vec4: ...
def dehomogeneous(hp: Vec4) -> Vec3: ...
def rotx(theta: float) -> Mat3: ...
def roty(theta: float) -> Mat3: ...
def rotz(theta: float) -> Mat3: ...
def aa2quat(axis: Vec3, angle: float) -> Vec4: ...
def aa2rot(aa: Vec3) -> Mat3: ...
def aa_vec(axis: Vec3, angle: float) -> Vec3: ...
def aa_decomp(aa: Vec3): ...
def vecs2aa(u: Vec3, v: Vec3) -> Vec3: ...
def euler321(
  yaw: float | np.float32 | np.float64,
  pitch: float | np.float32 | np.float64,
  roll: float | np.float32 | np.float64,
) -> Mat3: ...
def euler2quat(yaw: float, pitch: float, roll: float) -> Mat3: ...
def quat2euler(q: Vec4) -> Vec3: ...
def quat2rot(q: Vec4) -> Mat3: ...
def rot2euler(C: Mat3) -> Vec3: ...
def rot2quat(C: Mat3) -> Vec4: ...
def rot_diff(C0: Mat3, C1: Mat3, tol: float = 1e-5): ...

# Quaternions
def quat_norm(q: Vec4) -> float: ...
def quat_normalize(q: Vec4) -> Vec4: ...
def quat_conj(q: Vec4) -> Mat4: ...
def quat_inv(q: Vec4) -> Mat4: ...
def quat_left(q: Vec4) -> Mat4: ...
def quat_right(q: Vec4) -> Mat4: ...
def quat_lmul(p: Vec4, q: Vec4) -> Vec4: ...
def quat_rmul(p: Vec4, q: Vec4) -> Vec4: ...
def quat_mul(p: Vec4, q: Vec4) -> Vec4: ...
def quat_rot(q: Vec4, x: Vec3) -> Vec4: ...
def quat_omega(w: Vec3) -> Mat4: ...
def quat_delta(dalpha: Vec3) -> Vec4: ...
def quat_integrate(q_k: Vec4, w: Vec3, dt: float) -> Vec4: ...
def quat_slerp(q_i: Vec4, q_j: Vec4, t: float): ...

class TestQuaternion(unittest.TestCase): ...

# Transforms
def tf(rot: Mat3 | Vec4, trans: Vec3) -> Mat4: ...
def tf_rot(T: Mat4) -> Mat3: ...
def tf_quat(T: Mat4) -> Vec4: ...
def tf_euler(T: Mat4) -> Vec3: ...
def tf2pose(T: Mat4) -> Vec7: ...
def pose2tf(pose_vec: Vec7) -> Mat4: ...
def tf_trans(T: Mat4) -> Vec3: ...
def tf_inv(T: Mat4) -> Mat4: ...
def tf_point(T: Mat4, p: Vec3) -> Vec3: ...
def tf_hpoint(T: Mat4, hp: Vec4) -> Vec3: ...
def tf_decompose(T: Mat4): ...
def tf_lerp(pose_i: Mat4, pose_j: Mat4, t: float): ...
def rot_perturb(C: Mat3, i: int, step_size: float) -> Mat3: ...
def tf_perturb(T: Mat4, i: int, step_size: float) -> Mat4: ...
def tf_update(T: Mat4, dx: Vec3) -> Mat4: ...
def tf_diff(T0: Mat4, T1: Mat4) -> tuple[Vec3, float]: ...
def pose_diff(pose0: Mat4, pose1: Mat4) -> tuple[Vec3, float]: ...
def load_extrinsics(csv_path: str) -> Mat4 | None: ...
def load_poses(csv_path: str) -> list[tuple[float, Mat4]] | None: ...

###############################################################################
# MATPLOTLIB
###############################################################################

def plot_bbox(ax, center, size): ...
def plot_set_axes_equal(ax): ...
def confidence_ellipse(x, y, ax, n_std=3.0, facecolor="none", **kwargs): ...
def plot_tf(ax, T, **kwargs): ...
def plot_mav(ax, T, **kwargs): ...
def plot_xyz(title, data, key_time, key_x, key_y, key_z, ylabel, **kwargs): ...

###############################################################################
# CV
###############################################################################

# Utils
def z_score_normalization(image: Image): ...
def gamma_correction(image: Image, gamma: float = 0.5): ...
def histogram_equalization(image): ...
def find_modes_mean_shift(hist: VecN, sigma: float) -> tuple[MatNx2, VecN]: ...
def illumination_invariant_transform(image, alpha=0.9): ...

# Geometry
def lookat(cam_pos: Vec3, target_pos: Vec3, up_axis: Vec3) -> Mat4: ...
def linear_triangulation(
  P_i: Mat3x4,
  P_j: Mat3x4,
  z_i: Vec2,
  z_j: Vec2,
) -> Vec3: ...
def parallax(a: Vec3, b: Vec3) -> float: ...
def homography_find(pts_i: MatNx2, pts_j: MatNx2) -> Mat3: ...
def homography_pose(
  object_points: MatNx3,
  image_points: MatNx2,
  fx: float,
  fy: float,
  cx: float,
  cy: float,
) -> Mat4: ...
def dlt_pose(
  obj_pts: MatNx3,
  img_pts: MatNx2,
  fx: float,
  fy: float,
  cx: float,
  cy: float,
) -> Mat4: ...
def solvepnp(obj_pts, img_pts, fx, fy, cx, cy, **kwargs): ...

# Features 2D
def convolve2d(image: Image, kernel: MatN) -> Image: ...
def harris_corner(image_gray: Image, **kwargs) -> list[tuple[float, float]]: ...
def shi_tomasi_corner(image_gray: Image, **kwargs) -> list[tuple[int, int]]: ...

# Pinhole
def focal_length(image_width: int, fov_deg: float) -> float: ...
def pinhole_K(params: Vec4) -> Mat3: ...
def pinhole_P(params: Vec4, T_WC: Mat4) -> Mat34: ...
def pinhole_project(proj_params: Vec4, p_C: Vec3) -> Vec2: ...
def pinhole_back_project(proj_params: Vec4, z: Vec2) -> Vec2: ...
def pinhole_params_jacobian(x: Vec2) -> Mat2xN: ...
def pinhole_point_jacobian(proj_params: Vec4) -> Mat2: ...

# Radial-Tangential Distortion
def radtan4_distort(dist_params: Vec4, p: Vec2) -> Vec2: ...
def radtan4_point_jacobian(dist_params: Vec4, p: Vec2) -> Mat2: ...
def radtan4_undistort(dist_params: Vec4, p0: Vec2) -> Vec2: ...
def radtan4_params_jacobian(dist_params: Vec4, p: Vec2) -> Mat2xN: ...

# Equi-distant Distortion
def equi4_distort(dist_params: Vec4, p: Vec2) -> Vec2: ...
def equi4_undistort(dist_params: Vec4, p: Vec2) -> Vec2: ...
def equi4_params_jacobian(dist_params: Vec4, p: Vec2) -> Mat2xN: ...
def equi4_point_jacobian(dist_params: Vec4, p: Vec2) -> Mat2: ...

# Pinhole Radial-tangential4
def pinhole_radtan4_project(
  proj_params: Vec4,
  dist_params: Vec4,
  p_C: Vec3,
) -> Vec2: ...
def pinhole_radtan4_backproject(
  proj_params: Vec4,
  dist_params: Vec4,
  z: Vec2,
) -> Vec3: ...
def pinhole_radtan4_undistort(
  proj_params: Vec4,
  dist_params: Vec4,
  z: Vec2,
) -> Vec2: ...
def pinhole_radtan4_project_jacobian(
  proj_params: Vec4,
  dist_params: Vec4,
  p_C: Vec3,
) -> Mat2x3: ...
def pinhole_radtan4_params_jacobian(
  proj_params: Vec4,
  dist_params: Vec4,
  p_C: Vec3,
) -> Mat2xN: ...

# Pinhole Equi-distant
def pinhole_equi4_project(
  proj_params: Vec4,
  dist_params: Vec4,
  p_C: Vec3,
) -> Vec2: ...
def pinhole_equi4_backproject(
  proj_params: Vec4,
  dist_params: Vec4,
  z: Vec2,
) -> Vec3: ...
def pinhole_equi4_undistort(
  proj_params: Vec4,
  dist_params: Vec4,
  z: Vec2,
) -> Vec2: ...
def pinhole_equi4_project_jacobian(
  proj_params: Vec4,
  dist_params: Vec4,
  p_C: Vec3,
) -> Mat2x3: ...
def pinhole_equi4_params_jacobian(
  proj_params: Vec4,
  dist_params: Vec4,
  p_C: Vec3,
) -> Mat2xN: ...

# Camera Geometry
class CameraGeometry: ...

def pinhole_radtan4_setup(cam_idx, cam_res): ...
def pinhole_equi4_setup(cam_idx, cam_res): ...
def camera_geometry_setup(cam_idx, cam_res, proj_model, dist_model): ...

class ChessboardDetector: ...
class TestCV: ...

################################################################################
# POINT CLOUD
################################################################################

def umeyama(X: MatNx3, Y: MatNx3) -> tuple[float, Mat3, Vec3]: ...
def icp(
  X: MatNx3,
  Y: MatNx3,
  **kwargs,
) -> tuple[MatNx3, Mat3 | None, Vec3 | None]: ...

class TestPointCloud(unittest.TestCase): ...

################################################################################
# DATASET
################################################################################

# Timeline
class CameraEvent: ...
class ImuEvent: ...
class Timeline: ...

# EuRoC
class EurocSensor: ...
class EurocImuData: ...
class EurocCameraData: ...
class EurocGroundTruth: ...
class EurocDataset: ...
class TestEuroc(unittest.TestCase): ...

# KITTI
class KittiCameraData: ...
class KittiVelodyneData: ...
class KittiRawDataset: ...
class TestKitti(unittest.TestCase): ...

###############################################################################
# MANIPULATOR
###############################################################################

def fwdkinspace(M, S_list, theta_list): ...

###############################################################################
# FILTER
###############################################################################

def compl_filter(gyro, accel, dt, roll, pitch): ...

class KalmanFilter: ...
class TestKalmanFilter(unittest.TestCase): ...

###############################################################################
# OCTREE
###############################################################################

class Ray: ...
class Plane: ...
class Frustum: ...
class OctreeNode: ...
class Octree: ...
class TestPlane(unittest.TestCase): ...
class TestFrustum(unittest.TestCase): ...
class TestOctree(unittest.TestCase): ...

###############################################################################
# KD-Tree
###############################################################################

class KDNode: ...

def kdtree_build(points, depth=0): ...
def kdtree_nn(root, target): ...

class TestKDTree(unittest.TestCase): ...

###############################################################################
# STATE ESTIMATION
###############################################################################

# State-Variable
class StateVariableType(Enum): ...
class StateVariable: ...
class FeatureMeasurements: ...

def pose_setup(ts, param, **kwargs): ...
def extrinsics_setup(param, **kwargs): ...
def screw_axis_setup(param, **kwargs): ...
def camera_params_setup(
  cam_idx,
  res,
  proj_model,
  dist_model,
  param,
  **kwargs,
): ...
def feature_setup(param, **kwargs): ...
def speed_biases_setup(ts, vel, ba, bg, **kwargs): ...
def inverse_depth_setup(param, **kwargs): ...
def time_delay_setup(param, **kwargs): ...
def joint_angle_setup(param, **kwargs): ...
def perturb_state_variable(sv, i, step_size): ...
def perturb_pose(pose, dr, drot): ...
def perturb_pose_random(pose, pos_range, rot_range): ...
def perturb_tf_random(T, pos_range, rot_range): ...
def update_state_variable(sv, dx): ...
def idp_param(cam_params, T_WC, z): ...
def idp_param_jacobian(param): ...
def idp_point(param): ...

# Factor
class Factor: ...
class MeasurementFactor(Factor): ...
class PoseFactor(Factor): ...
class MultiCameraBuffer: ...
class BAFactor(Factor): ...
class VisionFactor(Factor): ...
class CalibVisionFactor(Factor): ...
class ImuBuffer: ...
class ImuParams: ...
class ImuFactorData: ...
class ImuFactorData2: ...
class ImuFactor(Factor): ...
class ImuFactor2(Factor): ...
class LidarFactor(Factor): ...
class MargFactor(Factor): ...

# Tests
class TestPoseFactor(unittest.TestCase): ...
class TestBAFactor(unittest.TestCase): ...
class TestVisionFactor(unittest.TestCase): ...
class TestCalibVisionFactor(unittest.TestCase): ...
class TestIMUFactor(unittest.TestCase): ...
class TestMargFactor(unittest.TestCase): ...
class FactorGraph: ...
class TestFactorGraph(unittest.TestCase): ...

###############################################################################
# FEATURE TRACKING
###############################################################################

def draw_matches(img_i: Image, img_j: Image, kps_i, kps_j) -> Image: ...
def draw_keypoints(
  img,
  kps,
  inliers=None,
  radius: int = 1,
  color: tuple[int, int, int] = (0, 255, 0),
): ...
def sort_keypoints(kps, des=None): ...
def spread_corners(img, corners, min_dist, **kwargs): ...
def spread_keypoints(img, kps, min_dist, **kwargs): ...
def spread_features(img, kps, des, min_dist, **kwargs): ...

class FeatureGrid: ...

def grid_detect(
  image: Image,
  max_keypoints: int = 2000,
  grid_rows: int = 3,
  grid_cols: int = 4,
  prev_kps=[],
  debug: bool = False,
): ...
def good_grid(
  image: Image,
  max_keypoints: int = 2000,
  quality_level: float = 0.001,
  use_harris: bool = True,
  min_dist: int = 20,
  grid_rows: int = 2,
  grid_cols: int = 3,
  prev_kps=[],
  debug=False,
): ...
def optflow_track(
  img_i: Image,
  img_j: Image,
  pts_i: VecN,
  pts_j: VecN | None = None,
  patch_size: int = 30,
  max_iter: int = 100,
  epsilon: float = 0.001,
  debug: bool = False,
): ...
def filter_outliers(pts_i, pts_j, inliers): ...
def check_parallax(
  cam0_params,
  cam1_params,
  cam0_exts,
  cam1_exts,
  kps0,
  kps1,
  parallax_threshold,
): ...
def ransac(pts_i, pts_j, cam_i, cam_j): ...
def estimate_pose(
  param_i,
  param_j,
  ext_i,
  ext_j,
  kps_i,
  kps_j,
  features,
  pose_i,
  **kwargs,
): ...

class FeatureTrack: ...
class TestFeatureTracking(unittest.TestCase): ...

###############################################################################
# CONTROL
###############################################################################

class PID: ...
class CarrotController: ...
class MavModel: ...
class MavAttitudeControl: ...
class MavVelocityControl: ...
class MavPositionControl: ...
class MavTrajectoryControl: ...

# Tests
class TestMav(unittest.TestCase): ...

###############################################################################
# Sandbox
###############################################################################

class TestPoE(unittest.TestCase): ...
